// Generated by CoffeeScript 1.4.0
(function() {
  var Task, fs, httpUtil, iconv, path, qs, requestQueue, url, _, _parseJSON, _stringifyJSON, _transform;

  fs = require('yi-fs');

  path = require('path');

  qs = require('querystring');

  url = require('url');

  iconv = require('iconv-lite');

  Task = require('yi-task').Task;

  _ = require('underscore');

  httpUtil = {};

  httpUtil._limitNumber = 20;

  httpUtil._proxyList = require('./proxylist');

  httpUtil._proxyIndex = 0;

  _transform = function(keys, val) {
    var arr;
    arr = [];
    _.each(val, function(v, k, obj) {
      if (_.isObject(v)) {
        return arr = arr.concat(_transform(keys.concat(k), v));
      } else {
        return arr.push({
          keys: keys.concat(k),
          val: v
        });
      }
    });
    return arr;
  };

  _stringifyJSON = function(json) {
    var jsonarr;
    jsonarr = [];
    _.each(json, function(val, key, obj) {
      if (!_.isObject(val)) {
        return jsonarr.push("" + key + "=" + (encodeURIComponent(val)));
      } else {
        return jsonarr = jsonarr.concat((_transform([], val)).map(function(kvs) {
          return ("" + key) + (kvs.keys.map(function(k) {
            return "[" + k + "]";
          })).join('') + ("=" + (encodeURIComponent(kvs.val)));
        }));
      }
    });
    return jsonarr.join('&');
  };

  _parseJSON = function(json) {
    var jsonarr;
    jsonarr = [];
    _.each(json, function(val, key, obj) {
      if (!_.isObject(val)) {
        return jsonarr.push("" + key + "=" + (encodeURIComponent(val)));
      } else {
        return jsonarr.push("" + key + "=" + (encodeURIComponent(JSON.stringify(val))));
      }
    });
    return jsonarr.join('&');
  };

  requestQueue = new Task('http request', httpUtil._limitNumber, function(options, config, callback, complete) {
    var isError, proxyhost, proxyinfo, proxyport, _request;
    isError = false;
    _request = function(options, config, callback) {
      var req, reqtimeout, t;
      req = (require(config.protocol)).request(options, function(res) {
        var buffer;
        buffer = new Buffer('');
        res.on('data', function(chunk) {
          var newbuffer;
          clearTimeout(reqtimeout);
          newbuffer = new Buffer(buffer.length + chunk.length);
          buffer.copy(newbuffer, 0);
          chunk.copy(newbuffer, buffer.length);
          return buffer = newbuffer;
        });
        return res.on('end', function() {
          var content, encode, json, jsonp, jumpUrl, regex;
          clearTimeout(reqtimeout);
          res.dt = Date.now() - t;
          content = buffer.toString();
          if (config.log) {
            console.log("Response statusCode:" + res.statusCode);
            console.log("Response headers:");
            console.log(res.headers);
            console.log("Response content:");
            console.log(content.substring(0, 1000));
            console.log("Request " + options.host + ":" + options.port + options.path + " need time " + res.dt);
          }
          if (res.statusCode === 200) {
            if (config.buffer) {
              complete(1, 0);
              if (!isError) {
                return callback(null, buffer, res);
              }
            } else {
              if (config.decode) {
                encode = (res.headers && res.headers['content-type'] && (/charset=(.*)/.test(res.headers['content-type'])) && res.headers['content-type'].match(/charset=(.*)/)[1]) || ((/charset="(.*?)"/.test(content)) && content.match(/charset="(.*?)"/)[1]) || 'GBK';
                content = iconv.decode(buffer, encode);
              }
              if (config.format === 'json') {
                try {
                  json = JSON.parse(content.replace(/\t/g, ''));
                } catch (e) {
                  complete(0, 1);
                  if (!isError) {
                    callback("JSON对象转换失败：" + e + "，内容是" + content, content, res);
                  }
                  return;
                }
                complete(1, 0);
                if (!isError) {
                  return callback(null, json, res);
                }
              } else {
                if (config.format === 'jsonp' && config.data && config.data.callback) {
                  try {
                    regex = new RegExp(config.data.callback + "\\(\(.*\)\\)");
                    if (regex.test(content)) {
                      jsonp = JSON.parse(content.match(regex)[1].replace(/\t/g, ''));
                    } else {
                      throw new Error("不能匹配jsonp");
                    }
                  } catch (e) {
                    complete(0, 1);
                    if (!isError) {
                      callback("JSONP对象转换失败：" + e + "，内容是" + content, content, res);
                    }
                    return;
                  }
                  complete(1, 0);
                  if (!isError) {
                    return callback(null, jsonp, res);
                  }
                } else {
                  complete(1, 0);
                  if (!isError) {
                    return callback(null, content, res);
                  }
                }
              }
            }
          } else {
            if (/^3\d\d$/.test(res.statusCode)) {
              config.maxDepth--;
              if (!config.maxDepth) {
                complete(1, 0);
                if (!isError) {
                  return callback(null, res.headers.location, res);
                }
              } else {
                if (config.log) {
                  console.log("Rediect to:" + res.headers.location);
                }
                jumpUrl = res.headers.location || res.headers.Location;
                config.url = jumpUrl;
                config.headers['Referer'] = "" + config.protocol + "://www." + options.host + ":" + options.port + options.path;
                complete(1, 0);
                return httpUtil._request(config, callback);
              }
            } else {
              if (!isError) {
                return callback(res.statusCode, content, res);
              }
            }
          }
        });
      });
      reqtimeout = setTimeout(function() {
        return req.emit('error', {
          message: "Request " + options.host + ":" + options.port + options.path + " Timeout!"
        });
      }, config.timeout);
      req.on('error', function(e) {
        if (!isError) {
          isError = true;
          req.abort();
          if (config.retry) {
            console.warn("Retry:" + config.retry + ",Error:" + e.message);
            config.retry--;
            complete(0, 1);
            return requestQueue.push(options, config, callback);
          } else {
            complete(0, 1);
            return callback("Request error: " + options.host + options.path + "出现以下错误：" + e.message);
          }
        }
      });
      if (options.method === 'POST' && config.data) {
        if (config.parseData) {
          req.write(JSON.stringify(config.data));
        } else {
          req.write(_stringifyJSON(config.data));
        }
      }
      t = Date.now();
      return req.end();
    };
    if (config.proxy) {
      if (_.isString(config.proxy)) {
        proxyinfo = config.proxy.split(':');
        proxyhost = proxyinfo[0];
        proxyport = proxyinfo[1] || 80;
        options.path = "http://www." + options.host + ":" + options.port + options.path;
        options.host = proxyhost;
        options.port = proxyport;
        options.headers.Host = url.parse(options.path).hostname;
        options.auth = ':';
        return _request(options, config, callback);
      } else {
        return httpUtil.getProxy(function(err, availProxy) {
          if (err) {
            complete(0, 1);
            callback(err);
          } else {
            options.path = "http://www." + options.host + ":" + options.port + options.path;
            options.host = availProxy.ip;
            options.port = availProxy.port;
            options.headers.Host = url.parse(options.path).hostname;
            options.auth = ':';
          }
          return _request(options, config, callback);
        });
      }
    } else {
      return _request(options, config, callback);
    }
  });

  httpUtil.getProxy = function(callback) {
    if (httpUtil._proxyList && httpUtil._proxyList.length) {
      httpUtil._currentProxy = httpUtil._proxyList[httpUtil._proxyIndex];
      callback(null, httpUtil._currentProxy);
      httpUtil._proxyIndex = (httpUtil._proxyIndex + 1) % httpUtil._proxyList.length;
      return httpUtil._currentProxy = httpUtil._proxyList[httpUtil._proxyIndex];
    } else {
      return callback("The Proxy List is Empty!", null);
    }
  };

  httpUtil._request = function(config, callback) {
    var options, protocol, reqObj, _base, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if ((_ref = config.retry) == null) {
      config.retry = 3;
    }
    if ((_ref1 = config.timeout) == null) {
      config.timeout = (function() {
        if (config.proxy) {
          return 10000;
        } else {
          return 5000;
        }
      })();
    }
    if ((_ref2 = config.maxDepth) == null) {
      config.maxDepth = 0;
    }
    if ((_ref3 = config.log) == null) {
      config.log = false;
    }
    if ((_ref4 = config.decode) == null) {
      config.decode = false;
    }
    if (config.url) {
      reqObj = url.parse(config.url);
      protocol = (function() {
        if (reqObj.protocol === 'https:') {
          return 'https';
        } else {
          return 'http';
        }
      })();
      _.extend(config, {
        protocol: protocol,
        host: "" + reqObj.protocol + "//" + reqObj.hostname,
        port: (function() {
          if (reqObj.port) {
            return reqObj.port;
          } else {
            if (protocol === 'https') {
              return 443;
            } else {
              return 80;
            }
          }
        })(),
        path: "" + reqObj.pathname,
        data: qs.parse(reqObj.query)
      });
    } else {
      config.protocol = (function() {
        if (config.host && ~config.host.indexOf('https')) {
          return 'https';
        } else {
          return 'http';
        }
      })();
    }
    options = {
      host: (config.host || 'localhost').replace('http://', '').replace('https://', ''),
      port: (function() {
        if (config.port) {
          return config.port;
        } else {
          if (config.protocol === 'https') {
            return 443;
          } else {
            return 80;
          }
        }
      })(),
      headers: (_ref5 = config.headers) != null ? _ref5 : config.headers = {},
      method: ((_ref6 = config.method) != null ? _ref6 : config.method = 'get').toUpperCase()
    };
    options.path = (function() {
      var querystring, _ref7;
      if (config.path && options.method === 'GET') {
        if (config.data) {
          if (config.parseData) {
            querystring = '?' + _parseJSON(config.data);
          } else {
            querystring = '?' + _stringifyJSON(config.data);
          }
        } else {
          querystring = '';
        }
        return config.path + querystring;
      } else {
        return (_ref7 = config.path) != null ? _ref7 : config.path = '/';
      }
    })();
    if (options.method === 'POST' && config.data) {
      if (config.parseData) {
        options.headers['Content-Type'] = 'application/json; charset=UTF-8';
        options.headers['Content-length'] = (new Buffer(JSON.stringify(config.data))).length;
      } else {
        if ((_ref7 = (_base = options.headers)['Content-Type']) == null) {
          _base['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        options.headers['Content-length'] = (new Buffer(_stringifyJSON(config.data))).length;
      }
    }
    if (config.log) {
      console.log('正在发送请求：');
      console.log(options);
    }
    return requestQueue.push(options, config, callback);
  };

  'get post'.split(' ').forEach(function(method) {
    return httpUtil[method] = function(config, callback) {
      if (_.isString(config)) {
        config = {
          url: config
        };
      }
      config.method = method;
      return httpUtil._request(config, callback);
    };
  });

  httpUtil.download = function(source, target, isCover, callback) {
    var dir;
    if (!callback) {
      if (_.isFunction(isCover)) {
        callback = isCover;
        isCover = true;
      } else {
        if (isCover == null) {
          isCover = true;
        }
      }
    }
    if (!isCover && fs.existsSync(target)) {
      if (callback) {
        return callback(null);
      }
    } else {
      dir = path.dirname(target);
      return fs.mkdirp(dir, function(err) {
        if (err) {
          if (callback) {
            return callback(err);
          } else {
            throw new Error(err);
          }
        } else {
          return httpUtil.get({
            url: source,
            buffer: true
          }, function(err, buffer) {
            if (err) {
              if (callback) {
                return callback(err);
              } else {
                throw new Error(err);
              }
            } else {
              if (callback) {
                return fs.writeFile(target, buffer, callback);
              } else {
                return fs.writeFileSync(target, buffer);
              }
            }
          });
        }
      });
    }
  };

  module.exports = httpUtil;

}).call(this);
